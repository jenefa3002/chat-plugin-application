{% load static %}
<html lang="en">
<head>
<meta
name="viewport"
content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>
<link rel="icon" href="{% static 'img/image01.png' %}" type="image/png">
<meta name="HandheldFriendly" content="true" />
<meta name="mobile-web-app-capable" content="yes" />
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta
name="viewport"
content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>
<title>ConnectSuite</title>
<link href="{% static 'css/chat.css' %}" rel="stylesheet"/>
<link
href="{% static 'vendor/fontawesome-free/css/all.min.css' %}"
rel="stylesheet"
type="text/css"
/>
<link href="{% static 'css/sb-admin-2.min.css' %}" rel="stylesheet" />
<link
href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
rel="stylesheet"
/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<link
rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
/>
</head>
<body>
<div class="header-tag">
<header class="header">
<div class="logo">
  <img src="{% static 'img/chat logo.png' %}" alt="logo" />
</div>
<div class="menu-toggle">
  <i class="fas fa-bars"></i>
</div>
<h2>Connect Suite</h2>
<ul class="nav-menu">
  <li><a href="/logout">Home</a></li>
  <li><a href="/users">About</a></li>
  <li><a href="#">Contact</a></li>
  <li><a href="/chatbot">Ari</a></li>
</ul>

<div class="user-info">
  <img
    src="{% static 'img/ProfilePic.png' %}"
    alt="Profile"
    class="profile-pic"
  />
  {% csrf_token %}
  <a href="{% url 'logout' %}" class="logout-button">
    <img
      src="https://img.icons8.com/?size=100&id=HqVUJDljsIvX&format=png&color=000000"
      alt="Logout"
    />
  </a>
</div>
</header>
</div>
<div class="background-effects">
<button class="chat-button">
<img src="{% static 'img/image03.png' %}" alt="Chat" />
<span class="chat-notification" id="chat-notification">!</span>
</button>
<div class="chat-panel">
<div class="chat-header">
  <h5>Chatty</h5>
  <div>
    <button class="call-history-button"><img src="https://img.icons8.com/?size=100&id=64894&format=png&color=000000" alt="call-history"></button>
    <button class="close-chat">&times;</button>
  </div>
</div>

<ul class="chat-list">
  {% for user in users %}
  <li data-username="{{ user.username }}" data-id="{{ user.id }}">
    <div class="d-flex align-items-center">
      <img
        src="https://img.icons8.com/?size=100&id=61005&format=png&color=000000"
        alt="User"
      />
      <span>{{ user.username }}</span>
      <span
        class="status-badge offline"
        id="user-status-{{ user.id }}"
      ></span>
    </div>
    <span
      class="badge bg-danger notification-badge"
      id="notification-badge-{{ user.username }}"
      style="display: none"
      >0</span
    >
  </li>
  {% endfor %}
</ul>
</div>
<div class="call-history-panel" style="display: none;">
  <div class="call-history-header">
      <h3>Call History</h3>
      <button class="close-call-history">&times;</button>
  </div>
  <div class="call-history-list"></div>
</div>
<div class="chat-content-panel"></div>
</div>
{% include 'chatbot.html' %}
<script>
$(document).ready(function() {
  $('.call-history-button').click(function() {
      loadCallHistory();
      $('.call-history-panel').show();
  });

  $('.close-call-history').click(function() {
      $('.call-history-panel').hide();
  });
});

function loadCallHistory() {
$.ajax({
url: '/get_call_history/',
type: 'GET',
success: function(data) {
    const historyList = $('.call-history-list');
    historyList.empty();

    if (!data.history || data.history.length === 0) {
        historyList.append('<div class="no-calls">No call history found</div>');
        return;
    }

    // Sort by timestamp descending
    data.history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    data.history.forEach(call => {
        let statusClass, statusText, statusIcon;

        // Handle all possible statuses
        switch(call.status.toLowerCase()) {
            case 'completed':
                statusClass = 'completed';
                statusText = 'Completed';
                statusIcon = 'fa-check-circle';
                break;
            case 'missed':
                statusClass = 'missed';
                statusText = 'Missed';
                statusIcon = 'fa-phone-slash';
                break;
            case 'rejected':
                statusClass = 'rejected';
                statusText = 'Rejected';
                statusIcon = 'fa-times-circle';
                break;
            case 'offline':
                statusClass = 'missed';
                statusText = 'User Offline';
                statusIcon = 'fa-user-slash';
                break;
            case 'timeout':
                statusClass = 'missed';
                statusText = 'No Answer';
                statusIcon = 'fa-clock';
                break;
            default:
                statusClass = 'other';
                statusText = call.status;
                statusIcon = 'fa-question-circle';
        }

        const callItem = $(`
            <div class="call-history-item ${statusClass}">
                <div class="call-icon">
                    <i class="fas ${call.call_type === 'video' ? 'fa-video' : 'fa-phone'}"></i>
                </div>
                <div class="call-details">
                    <div class="call-participant">
                        ${call.other_user}
                    </div>
                    <div class="call-direction">
                        ${call.direction === 'outgoing' ? 'Incoming' : 'Outgoing' } ${call.call_type} call
                    </div>
                    <div class="call-status ${statusClass}">
                        <i class="fas ${statusIcon}"></i> ${statusText}
                    </div>
                    <div class="call-time">
                        ${new Date(call.timestamp).toLocaleString()}
                        ${call.duration ? ' • ' + formatDuration(call.duration) : ''}
                    </div>
                </div>
            </div>
        `);
        historyList.append(callItem);
    });
},
error: function(error) {
    console.error('Error loading call history:', error);
    $('.call-history-list').html('<div class="no-calls">Error loading call history</div>');
}
});
}

function formatDuration(seconds) {
if (seconds == null || isNaN(seconds)) return '';
const minutes = Math.floor(seconds / 60);
const remainingSeconds = seconds % 60;
return `${minutes}m ${remainingSeconds}s`;
}

class VideoCall {
constructor() {
  this.peerConnections = {};
  this.callStartTimes = this.callStartTimes || {};
  this.callTimeouts = {};
  this.localStreams = {};
  this.remoteStreams = {};
  this.makingOffer = {};
  this.ignoreOffer = {};
  this.polite = {};
  this.peerData = {};
  this.callSockets = {};
  this.messageQueue = {};
  this.lastProcessedMessages = {};
  this.activeCallRequests = {};
  this.lastMessages = {};
  this.callStates = {};
  this.callCooldowns = {};
  this.activeCalls = {};
  this.callDirections = {};
  this.processedSignalingMessages = {};
  this.rtcConfig = {
    iceServers: [
      {
        urls: "turn:relay1.expressturn.com:3478",
        username: "ef0OSL1KJJM05XK829",
        credential: "4HQgeo0mAcWomtgj",
      },
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:stun1.l.google.com:19302",
          "stun:stun2.l.google.com:19302",
        ],
      },
    ],
    iceTransportPolicy: "all",
    bundlePolicy: "max-bundle",
    rtcpMuxPolicy: "require",
    iceCandidatePoolSize: 10,
  };
}

async initVideoCall(chatPanelId, sender, recipient) {
  try {
    console.log(`Initializing video call for ${chatPanelId}`);
    this.cleanupVideoCall(chatPanelId);
    this.peerData[chatPanelId] = { sender, recipient };
    this.polite[chatPanelId] = true;
    this.makingOffer[chatPanelId] = false;
    this.ignoreOffer[chatPanelId] = false;

    this.callSockets[chatPanelId] = new WebSocket(
      window.location.protocol === "https:"
        ? `wss://${window.location.host}/ws/videocall/${sender}/${recipient}/`
        : `ws://${window.location.host}/ws/videocall/${sender}/${recipient}/`
    );

    this.callSockets[chatPanelId].onopen = async () => {
      if (!this.peerConnections[chatPanelId]) {
        await this.createPeerConnection(chatPanelId);
      }
    };

    this.setupCallSocketHandlers(chatPanelId);
    this.createVideoElements(chatPanelId);
    this.setupCallEventListeners(chatPanelId);

    console.log(`Video call initialized for ${chatPanelId}`);
  } catch (error) {
    console.error(`Error initializing video call: ${error}`);
    this.showError(chatPanelId, "Failed to initialize video call");
  }
}

setupCallSocketHandlers(chatPanelId) {
  const socket = this.callSockets[chatPanelId];
  this.lastMessages = this.lastMessages || {};
  socket.onopen = async () => {
    console.log(`Video call WebSocket opened for ${chatPanelId}`);
    this.updateCallStatus(chatPanelId, "connecting");
    await this.createPeerConnection(chatPanelId);
    this.processMessageQueue(chatPanelId);
  };

  socket.onerror = (error) => {
    console.error(`WebSocket error for ${chatPanelId}:`, error);
    this.updateCallStatus(chatPanelId, "disconnected");
    this.cleanupSocket(chatPanelId);
    if (this.callStates[chatPanelId] === 'initiating') {
        this.logMissedCall(chatPanelId, sender, recipient);
          window.showMissedCallNotification({
                caller: sender,
                receiver: recipient,
                call_type: 'video',
                timestamp: new Date().toISOString()
            });
        tabNotifier.showNotification(`Missed video call from ${sender}`);
        this.endCall(chatPanelId);
    }
  };
  socket.onclose = () => {
    console.log(`WebSocket closed for ${chatPanelId}`);
    this.updateCallStatus(chatPanelId, "disconnected");
  };

  socket.onmessage = async (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log(`Received ${data.type} for ${chatPanelId}`, data);
      if (!this.isValidCallMessageType(data.type)) {
        console.warn(`Invalid message type: ${data.type}`);
        return;
      }

      if (!this.isPeerConnectionReady(chatPanelId)) {
        console.log(`PeerConnection not ready, queuing ${data.type}`);
        this.queueMessage(chatPanelId, data);
        return;
      }

      await this.processCallSignalingMessage(chatPanelId, data);
    } catch (error) {
      console.error(`Error handling message for ${chatPanelId}:`, error);
    }
  };
}
cleanupSocket(chatPanelId) {
  if (this.callSockets[chatPanelId]) {
      this.callSockets[chatPanelId].onclose = null;
      this.callSockets[chatPanelId].close();
      delete this.callSockets[chatPanelId];
  }
}
 async processMessageQueue(chatPanelId) {
  if (!this.messageQueue[chatPanelId] || this.messageQueue[chatPanelId].length === 0) {
    return;
  }
  while (this.messageQueue[chatPanelId].length > 0 && this.isPeerConnectionReady(chatPanelId)) {
    const message = this.messageQueue[chatPanelId].shift();
    try {
      await this.processCallSignalingMessage(chatPanelId, message);
    } catch (error) {
      console.error(`Error processing queued ${message.type}:`, error);
    }
  }
}

queueMessage(chatPanelId, message) {
  if (!this.messageQueue[chatPanelId]) {
    this.messageQueue[chatPanelId] = [];
  }
  this.messageQueue[chatPanelId].push(message);
}

createVideoElements(chatPanelId) {
  const container = document.getElementById(`video-call-container-${chatPanelId}`);
  if (!container) {
    return;
  }
  if (!document.getElementById(`localVideoCall-${chatPanelId}`)) {
    const localVideo = document.createElement("video");
    localVideo.id = `localVideoCall-${chatPanelId}`;
    localVideo.className = "localVideo";
    localVideo.autoplay = true;
    localVideo.muted = true;
    localVideo.playsInline = true;
    container.insertBefore(localVideo, container.firstChild);
  }
  if (!document.getElementById(`remoteVideoCall-${chatPanelId}`)) {
    const remoteVideo = document.createElement("video");
    remoteVideo.id = `remoteVideoCall-${chatPanelId}`;
    remoteVideo.className = "remoteVideo";
    remoteVideo.autoplay = true;
    remoteVideo.playsInline = true;
    container.insertBefore(remoteVideo, container.firstChild);
  }
  if (!container.querySelector('.call-controls')) {
    const callControls = document.createElement("div");
    callControls.className = "call-controls";
    callControls.innerHTML = `
      <button class="end-call-btn" id="end-call-btn-${chatPanelId}">
        <img alt="end call" src="https://img.icons8.com/?size=100&id=20578&format=png&color=000000">
      </button>
      <button class="mute-btn" id="mute-btn-${chatPanelId}">
        <img alt="Mute" src="https://img.icons8.com/?size=100&id=JtlARuXJXaPI&format=png&color=000000">
      </button>
      <button class="video-off-btn" id="video-off-btn-${chatPanelId}">
        <img src="https://img.icons8.com/?size=100&id=GQ1GoxtCGHG4&format=png&color=000000" alt="Video off">
      </button>
    `;
    container.appendChild(callControls);
  }
  if (!document.getElementById(`call-status-${chatPanelId}`)) {
    const statusIndicator = document.createElement("div");
    statusIndicator.id = `call-status-${chatPanelId}`;
    statusIndicator.className = "connection-status";
    container.appendChild(statusIndicator);
  }
}

setupCallEventListeners(chatPanelId) {
  const { sender, recipient } = this.peerData[chatPanelId] || {};
  if (!sender || !recipient) return;
  $(`#video-call-btn-${chatPanelId}`).off('click').on('click', async () => {
    if (this.localStreams[chatPanelId]) {
      await this.endCall(chatPanelId);
    } else {
      await this.startCall(chatPanelId, sender, recipient);
    }
  });
  $(`#end-call-btn-${chatPanelId}`).off('click').on('click', async () => {
    await this.endCall(chatPanelId);
  });
  $(`#mute-btn-${chatPanelId}`).off('click').on('click', () => {
    this.toggleMute(chatPanelId);
  });
  $(`#video-off-btn-${chatPanelId}`).off('click').on('click', () => {
    this.toggleVideo(chatPanelId);
  });
  $(document).on(`click`, `.close-chat-content[data-id="${chatPanelId}"]`, () => {
    this.cleanupVideoCall(chatPanelId);
  });
}

async startCall(chatPanelId, sender, recipient) {
 this.callDirection = 'outgoing';
  if (this.callTimeouts[chatPanelId]) {
    clearTimeout(this.callTimeouts[chatPanelId]);
  }
  if (this.activeCalls[recipient]) {
   this.showNotification(chatPanelId, "User is already in another call");
    return;
  }
  this.activeCalls[recipient] = chatPanelId;
  if (this.callStates[chatPanelId] && this.callStates[chatPanelId] !== 'idle') {
    return;
  }
  if (this.callCooldowns[chatPanelId] &&
    Date.now() - this.callCooldowns[chatPanelId] < 2000) {
    return;
  }
  this.callCooldowns[chatPanelId] = Date.now();
  this.callStates[chatPanelId] = 'initiating';
  try {
    console.log(`Starting call for ${chatPanelId}`);
      const waitingUI = $(`
        <div id="call-waiting-${chatPanelId}" class="call-waiting-modal">
          <div class="call-waiting-content">
            <div class="call-waiting-text">
              <div class="call-waiting-spinner"></div>
              <span>Calling...</span>
            </div>
            <div class="call-waiting-buttons">
              <button class="cancel-call">
                <img src="https://img.icons8.com/?size=100&id=20578&format=png&color=000000" alt="Cancel">
              </button>
            </div>
          </div>
        </div>
      `);

      $(`#${chatPanelId} .chat-container`).append(waitingUI);
      waitingUI.find('.cancel-call').click(async() => {
        window.logRejectedCall(sender, recipient);
        await this.handleCallRejection(chatPanelId, data);
        waitingUI.remove();
      });
    $(`#video-call-container-${chatPanelId}`).show();
    this.updateCallStatus(chatPanelId, "connecting");

    try {
      this.localStreams[chatPanelId] = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      }).catch(async (videoError) => {
        return await navigator.mediaDevices.getUserMedia({ audio: true });
      });
      const localVideo = document.getElementById(`localVideoCall-${chatPanelId}`);
      if (localVideo) {
        if (this.localStreams[chatPanelId].getVideoTracks().length > 0) {
          localVideo.srcObject = this.localStreams[chatPanelId];
          localVideo.classList.add("active");
          localVideo.play().catch(e => console.log("Local video play error:", e));
        } else {
          localVideo.style.display = "none";
          this.showNotification(chatPanelId, "Starting audio-only call (no video available)");
        }
      }
      this.localStreams[chatPanelId].getTracks().forEach(track => {
        this.peerConnections[chatPanelId].addTrack(track, this.localStreams[chatPanelId]);
      });
      if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "call_initiate",
          sender: sender,
          recipient: recipient,
          hasVideo: this.localStreams[chatPanelId].getVideoTracks().length > 0,
          hasAudio: this.localStreams[chatPanelId].getAudioTracks().length > 0,
          direction: "outgoing",
          timestamp: new Date().toISOString()
        }));
      }
    } catch (error) {
      console.error(`Error getting media devices: ${error}`);
      waitingUI.remove();
      this.endCall(chatPanelId);
      if (error.name !== "NotAllowedError") {
        this.showError(chatPanelId, `Could not start call: ${error.message}`);
      }
      this.callStates[chatPanelId] = 'idle';
      throw error;
    }
    this.setupCallTimeout(chatPanelId, sender, recipient);
  } catch (error) {
    console.error(`Error starting call: ${error}`);
    this.endCall(chatPanelId);
    if (error.name !== "NotAllowedError") {
      this.showError(chatPanelId, `Could not start call: ${error.message}`);
    }
    this.callStates[chatPanelId] = 'idle';
    throw error;
  }
}
setupCallTimeout(chatPanelId, sender, recipient) {
  if (this.callTimeouts[chatPanelId]) {
    clearTimeout(this.callTimeouts[chatPanelId]);
  }
  this.callTimeouts[chatPanelId] = setTimeout(async () => {
    if (this.callStates[chatPanelId] === 'initiating') {
        console.log(`Call timeout reached for ${chatPanelId}`);
        if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
            this.callSockets[chatPanelId].send(JSON.stringify({
                type: "call_rejected",
                sender: recipient,
                recipient: sender,
                reason: "timeout"
            }));
            this.handleCallRejection(chatPanelId, sender, recipient);
        }
        try {
            await this.handleMissedCall(sender, recipient);
            window.showMissedCallNotification({
                caller: sender,
                receiver: recipient,
                call_type: 'video',
                timestamp: new Date().toISOString()
            });
            tabNotifier.showNotification(`Missed video call from ${sender}`);
            if ($('.call-history-panel').is(':visible')) {
                loadCallHistory();
            }
        } catch (error) {
            console.error('Error handling missed call:', error);
        }
        this.endCall(chatPanelId);
        $(`#call-waiting-${chatPanelId}`).remove();
    }
  }, 45000);
}

setAudioOnlyUI(chatPanelId, isAudioOnly) {
  const container = document.getElementById(`video-call-container-${chatPanelId}`);
  if (!container) return;
  const existingIndicator = container.querySelector('.audio-only-indicator');
  if (existingIndicator) existingIndicator.remove();
  const localVideo = document.getElementById(`localVideoCall-${chatPanelId}`);
  if (localVideo) {
    localVideo.style.display = isAudioOnly ? "none" : "block";
  }
  if (isAudioOnly) {
    //use a image to indicate if needed
  }
}

showNotification(chatPanelId, message, duration = 8000) {
  $(`#notification-${chatPanelId}`).remove();
  const notification = $(`
    <div id="notification-${chatPanelId}" class="call-notification">
      ${message}
    </div>
  `);
  $(`#video-call-container-${chatPanelId}`).append(notification);
  setTimeout(() => {
    notification.fadeOut(1000, () => notification.remove());
  }, duration);
}

async createPeerConnection(chatPanelId) {
  if (this.peerConnections[chatPanelId]) {
    if (['closed', 'failed'].includes(this.peerConnections[chatPanelId].connectionState)) {
      this.peerConnections[chatPanelId].close();
      delete this.peerConnections[chatPanelId];
    } else {
      return true;
    }
  }

  try {
    console.log(`Creating PeerConnection for video call ${chatPanelId}`);
    this.peerConnections[chatPanelId] = new RTCPeerConnection(this.rtcConfig);
    this.updateCallStatus(chatPanelId, "connecting");
    this.setupPeerConnectionHandlers(chatPanelId);
    console.log(`PeerConnection created for ${chatPanelId}`);
    return true;
  } catch (error) {
    console.error(`Error creating PeerConnection: ${error}`);
    this.updateCallStatus(chatPanelId, "disconnected");
    return false;
  }
}

setupPeerConnectionHandlers(chatPanelId) {
  const pc = this.peerConnections[chatPanelId];
  if (!pc) return;

  pc.onicecandidate = ({ candidate }) => {
    console.log(`ICE candidate for ${chatPanelId}:`, candidate);
    if (candidate && this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
      this.callSockets[chatPanelId].send(JSON.stringify({
        type: "candidate",
        candidate: candidate,
      }));
    }
  };

  pc.onnegotiationneeded = async () => {
    try {
      console.log(`Negotiation needed for ${chatPanelId}`);
      this.makingOffer[chatPanelId] = true;
      await pc.setLocalDescription();
      console.log(`Local description set:`, pc.localDescription);

      if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "offer",
          offer: pc.localDescription,
        }));
        console.log(`Offer sent for ${chatPanelId}`);
      }
    } catch (err) {
      console.error(`Negotiation error for ${chatPanelId}:`, err);
    } finally {
      this.makingOffer[chatPanelId] = false;
    }
  };

  pc.oniceconnectionstatechange = () => {
    const state = pc.iceConnectionState;
    console.log(`ICE connection state changed to ${state} for ${chatPanelId}`);
    this.updateCallStatus(chatPanelId, state);
    if (state === "failed") {
        const { sender, recipient } = this.peerData[chatPanelId] || {};
        if (sender && recipient) {
            this.logMissedCall(chatPanelId, sender, recipient);
            window.showMissedCallNotification({
                caller: sender,
                receiver: recipient,
                call_type: 'video',
                timestamp: new Date().toISOString()
            });
        }
        this.endCall(chatPanelId);
    }
  };

  pc.ontrack = (event) => {
    console.log("Track event received:", event);
    const remoteVideo = document.getElementById(`remoteVideoCall-${chatPanelId}`);
    if (!remoteVideo) {
      console.error("Remote video element not found");
      return;
    }

    if (!this.remoteStreams[chatPanelId] && event.streams && event.streams.length > 0) {
      this.remoteStreams[chatPanelId] = event.streams[0];
      remoteVideo.srcObject = this.remoteStreams[chatPanelId];

      remoteVideo.onplay = () => {
        const playBtn = document.querySelector(`#video-call-container-${chatPanelId} .video-play-button`);
        if (playBtn) playBtn.remove();
      };

      const playPromise = remoteVideo.play();
      if (playPromise !== undefined) {
        playPromise.catch((error) => {
          console.log("Autoplay prevented, showing play button");
          this.showPlayButton(chatPanelId, remoteVideo);
        });
      }
    }
  };

  pc.onconnectionstatechange = () => {
    const state = pc.connectionState;
    console.log(`Connection state changed to ${state} for ${chatPanelId}`);
    if (state === "failed") {
      console.log("ICE failed - restarting ICE");
      pc.restartIce();
      setTimeout(() => {
        if (!this.peerConnections[chatPanelId]) {
          this.initVideoCall(chatPanelId, this.peerData[chatPanelId].sender,
                           this.peerData[chatPanelId].recipient);
        }
      }, 8000);
    }
    switch (state) {
      case "connected":
        this.handleConnectionSuccess(chatPanelId);
        this.callStates[chatPanelId] = 'active';
        this.callStartTimes[chatPanelId] = Date.now();
        break;
      case "failed":
        if (!this.isClosingCall || !this.isClosingCall[chatPanelId]) {
          this.showNotification(chatPanelId, "Call disconnected");
          this.endCall(chatPanelId);
        }
        setTimeout(() => {
          const { sender, recipient } = this.peerData[chatPanelId] || {};
          if (sender && recipient && !this.peerConnections[chatPanelId]) {
            this.initVideoCall(chatPanelId, sender, recipient);
          }
        }, 2000);
        break;
      case "disconnected":
        this.endCall(chatPanelId);
        break;
    }
  };
}

async processCallSignalingMessage(chatPanelId, data) {
  const messageId = `${data.type}-${JSON.stringify(data.offer || data.answer || data.candidate)}`;
  if (this.processedSignalingMessages[chatPanelId]?.has(messageId)) {
    console.log(`Ignoring duplicate ${data.type} message`);
    return;
  }
  if (!this.processedSignalingMessages[chatPanelId]) {
    this.processedSignalingMessages[chatPanelId] = new Set();
  }
  this.processedSignalingMessages[chatPanelId].add(messageId);
  if (!this.peerConnections[chatPanelId]) {
    console.log(`PeerConnection not ready, queuing ${data.type}`);
    this.queueMessage(chatPanelId, data);
    return;
  }

  const pc = this.peerConnections[chatPanelId];
  const currentDescription = pc.remoteDescription || pc.localDescription;
  if (this.lastProcessedMessages[chatPanelId] === data.type + data.sender) {
    return;
  }
  this.lastProcessedMessages[chatPanelId] = data.type + data.sender;
  if (currentDescription && data.type === currentDescription.type) {
    console.log(`Ignoring duplicate ${data.type}`);
    return;
  }

  switch (data.type) {
    case "call_initiate":
      await this.handleCallInitiation(chatPanelId, data);
      break;
    case "offer":
      await this.handleOffer(chatPanelId, data.offer);
      break;
    case "answer":
      await this.handleAnswer(chatPanelId, data.answer);
      break;
    case "candidate":
      await this.handleCandidate(chatPanelId, data.candidate);
      break;
    case "end_call":
      await this.endCall(chatPanelId);
      break;
    case "call_rejected":
      await this.handleCallRejection(chatPanelId, data.sender, data.recipient);
      break;
  }
}

handleConnectionSuccess(chatPanelId) {
    console.log(`Connection established for ${chatPanelId}`);
    const statusElement = document.getElementById(`call-status-${chatPanelId}`);
    if (statusElement) {
      statusElement.className = "connection-status connected";
    }
    this.monitorConnectionQuality(chatPanelId);
  }

  monitorConnectionQuality(chatPanelId) {
    const pc = this.peerConnections[chatPanelId];
    if (!pc) return;

    setInterval(() => {
      pc.getStats().then(stats => {
        stats.forEach(report => {
          if (report.type === 'candidate-pair' && report.nominated) {
            console.log(`Connection quality for ${chatPanelId}:`, {
              rtt: report.currentRoundTripTime,
              availableOutgoingBitrate: report.availableOutgoingBitrate
            });
          }
        });
      });
    }, 60000);
  }
async handleCallInitiation(chatPanelId, data) {
  this.callDirection = 'incoming';
  if (this.activeCallRequests[chatPanelId]) {
    console.log(`Already handling call request for ${chatPanelId}`);
    return;
  }
  if (data.recipient !== "{{ request.user.username }}") {
    return;
  }
  this.activeCallRequests[chatPanelId] = data.sender;
  if (document.getElementById(`call-confirmation-${chatPanelId}`)) {
    return;
  }
  const confirmation = $(`
    <div id="call-confirmation-${chatPanelId}" class="call-confirmation-modal">
      <div class="call-confirmation-content">
         <p>Incoming call from ${data.sender}</p>
          <div class="call-timer">00:45</div>
          <div class="call-confirmation-buttons">
          <button class="accept-call"><img src="https://img.icons8.com/?size=100&id=9660&format=png&color=000000" alt="Accept"></button>
          <button class="reject-call"><img src="https://img.icons8.com/?size=100&id=20578&format=png&color=000000" alt="Decline"></button>
        </div>
      </div>
    </div>
  `);
  $(`#${chatPanelId} .chat-container`).append(confirmation);
  let isCallAnswered = false;
  let secondsLeft = 45;
  const timerElement = confirmation.find('.call-timer');
  const timerInterval = setInterval(() => {
    secondsLeft--;
    timerElement.text(`00:${secondsLeft.toString().padStart(2,'0')}`);
  }, 1000);
  return new Promise((resolve) => {
    confirmation.find('.accept-call').click(async () => {
      isCallAnswered = true;
      clearTimeout(timeout);
      confirmation.remove();
      this.setupCallEventListeners(chatPanelId);
      await this.startCall(chatPanelId, data.recipient, data.sender);
      resolve(true);
    });
    confirmation.find('.reject-call').click(async() => {
      clearTimeout(timeout);
      await this.handleCallRejection(chatPanelId, data.sender, data.recipient);
      confirmation.remove();
      resolve(false);
    });
    const timeout = setTimeout(() => {
      if (!isCallAnswered) {
        window.logRejectedCall(data.sender, data.recipient);
        window.showMissedCallNotification({
          caller: data.sender,
          receiver: data.recipient,
          call_type: 'video',
          status: 'timeout',
          timestamp: new Date().toISOString()
        });
        this.handleCallRejection(chatPanelId, data.sender, data.recipient, "timeout");
        confirmation.remove();
        resolve(false);
      }
      if (this.callStates[chatPanelId] === 'initiating') {
        window.logMissedCall(data.sender, data.recipient, 'timeout');
        window.showMissedCallNotification({
          caller: data.sender,
          receiver: data.recipient,
          call_type: 'video',
          status: 'timeout',
          timestamp: new Date().toISOString()
        });
        this.handleCallRejection(chatPanelId, data.sender, data.recipient, "timeout");
        confirmation.remove();
        resolve(false);
      }
    }, 45000);
  });
}


async handleOffer(chatPanelId, offer) {
  try {
    const pc = this.peerConnections[chatPanelId];
    if (!pc) return;
    const isSimilarOffer = pc.remoteDescription &&
      pc.remoteDescription.sdp.split('\r\n').slice(0,3).join() ===
      offer.sdp.split('\r\n').slice(0,3).join();

    if (isSimilarOffer) {
      console.log("Similar offer - responding with existing answer");
      if (pc.localDescription) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "answer",
          answer: pc.localDescription
        }));
      }
      return;
    }

    if (pc.remoteDescription && pc.remoteDescription.sdp.split('\r\n')[1] === offer.sdp.split('\r\n')[1]) {
      console.log("Similar offer - ignoring");
      return;
    }
    const offerCollision = this.makingOffer[chatPanelId] ||
                         (pc.signalingState !== "stable" && pc.signalingState !== "have-local-offer");

    this.ignoreOffer[chatPanelId] = !this.polite[chatPanelId] && offerCollision;
    if (this.ignoreOffer[chatPanelId]) {
      console.log(`Ignoring offer for ${chatPanelId} due to collision`);
      return;
    }

    await pc.setRemoteDescription(new RTCSessionDescription(offer));

    if (offer.type === "offer") {
      await pc.setLocalDescription();
      this.callSockets[chatPanelId].send(JSON.stringify({
        type: "answer",
        answer: pc.localDescription,
      }));
    }
  } catch (error) {
    console.error(`Error handling offer: ${error}`);
    this.endCall(chatPanelId);
  }
}

async handleAnswer(chatPanelId, answer) {
  try {
    console.log("Processing answer", answer);
    const pc = this.peerConnections[chatPanelId];

    if (!pc || pc.signalingState === "closed") {
      console.warn("PeerConnection not ready for answer");
      return;
    }
    $(`#call-waiting-${chatPanelId}`).remove();
    this.callStates[chatPanelId] = 'active';
    if (pc.remoteDescription && pc.remoteDescription.type === 'answer' &&
        pc.remoteDescription.sdp === answer.sdp) {
      console.log("Ignoring duplicate answer");
      return;
    }
    if (pc.signalingState === "have-local-offer" || pc.signalingState === "stable") {
      if (!pc.remoteDescription) {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        console.log("Answer processed successfully");
      } else {
        console.log("Ignoring duplicate answer");
      }
    } else {
      console.warn(`Unexpected signaling state for answer: ${pc.signalingState}`);
      this.queueMessage(chatPanelId, { type: "answer", answer });
    }
  } catch (error) {
    console.error("Error handling answer:", error);
    throw error;
  }
}
async handleMissedCall(chatPanelId, sender, recipient) {
  try {
      await fetch('/log_missed_call/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken'),
          },
          body: JSON.stringify({
              caller: sender,
              receiver: recipient,
              call_type: 'video',
              reason: 'missed'
          })
      });
      if ($('.call-history-panel').is(':visible')) {
          loadCallHistory();
      }
  } catch (error) {
      console.error('Error handling missed call:', error);
  }
}
async handleCandidate(chatPanelId, candidate) {
  try {
    const pc = this.peerConnections[chatPanelId];
    if (!pc || pc.signalingState === "closed") return;
    if (!candidate || this.ignoreOffer[chatPanelId]) return;
    if (!pc.remoteDescription) {
      await new Promise(resolve => {
        const checkDesc = () => {
          if (pc.remoteDescription) {
            resolve();
          } else {
            setTimeout(checkDesc, 100);
          }
        };
        checkDesc();
      });
    }
    await pc.addIceCandidate(new RTCIceCandidate(candidate));
  } catch (err) {
    if (!this.ignoreOffer[chatPanelId]) {
      console.error("Failed to add ICE candidate:", err);
    }
  }
}

toggleMute(chatPanelId) {
  if (this.localStreams[chatPanelId]) {
    const audioTracks = this.localStreams[chatPanelId].getAudioTracks();
    if (audioTracks.length > 0) {
      const isMuted = !audioTracks[0].enabled;
      audioTracks[0].enabled = isMuted;

      const muteBtn = document.getElementById(`mute-btn-${chatPanelId}`);
      if (muteBtn) {
        muteBtn.innerHTML = isMuted
          ? '<img alt="Mute" src="https://img.icons8.com/?size=100&id=644&format=png&color=000000">'
          : '<img alt="Unmute" src="https://img.icons8.com/?size=100&id=41562&format=png&color=000000">';
      }
      if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "mute_status",
          isMuted: !isMuted
        }));
      }
    }
  }
}

toggleVideo(chatPanelId) {
  if (this.localStreams[chatPanelId]) {
    const videoTracks = this.localStreams[chatPanelId].getVideoTracks();
    if (videoTracks.length > 0) {
      const isVideoOff = !videoTracks[0].enabled;
      videoTracks[0].enabled = isVideoOff;

      const videoBtn = document.getElementById(`video-off-btn-${chatPanelId}`);
      if (videoBtn) {
        videoBtn.innerHTML = isVideoOff
          ? '<img src="https://img.icons8.com/?size=100&id=GQ1GoxtCGHG4&format=png&color=000000" alt="Video off">'
          : '<img src="https://img.icons8.com/?size=100&id=11374&format=png&color=000000" alt="Video on">';
      }
      if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "video_status",
          isVideoOff: !isVideoOff
        }));
      }
    }
  }
}

async handleCallRejection(chatPanelId, sender, recipient, reason = "rejected") {
  if (this.callStates[chatPanelId] === 'rejected') return;
  console.log(`Call rejected by ${sender}, reason: ${reason}`);
  this.callStates[chatPanelId] = 'rejected';
  if (this.callTimeouts[chatPanelId]) {
      clearTimeout(this.callTimeouts[chatPanelId]);
      delete this.callTimeouts[chatPanelId];
  }
  if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
      this.callSockets[chatPanelId].send(JSON.stringify({
          type: "call_rejected",
          sender: sender,
          recipient: recipient,
          reason: reason
      }));
  }
  try {
      const endpoint = reason === "timeout" ? '/log_missed_call/' : '/log_rejected_call/';
      await fetch(endpoint, {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken'),
          },
          body: JSON.stringify({
              caller: sender,
              receiver: recipient,
              call_type: 'video',
              reason: reason
          })
      });

      if (reason === "timeout") {
          window.showMissedCallNotification({
              caller: sender,
              receiver: recipient,
              call_type: 'video',
              timestamp: new Date().toISOString()
          });
          tabNotifier.showNotification(`Missed video call from ${recipient}`);
      }
  } catch (error) {
      console.error('Error logging call rejection:', error);
  }
    await this.endCall(chatPanelId);
    $(`#call-waiting-${chatPanelId}`).remove();
    $(`#call-confirmation-${chatPanelId}`).remove();
}

async endCall(chatPanelId) {
  if (this.callTimeouts[chatPanelId]) {
    clearTimeout(this.callTimeouts[chatPanelId]);
  }
  const { sender, recipient } = this.peerData[chatPanelId] || {};

  if (this.callStates[chatPanelId] === 'active' && sender && recipient) {
      const duration = Math.floor((Date.now() - this.callStartTimes[chatPanelId]) / 1000);
      await window.logCompletedCall(
              this.peerData[chatPanelId].sender,
              this.peerData[chatPanelId].recipient,
              duration);
  }
  if (this.callStates[chatPanelId] === 'ending' || this.callStates[chatPanelId] === 'idle') {
    return;
  }
  $(`#call-waiting-${chatPanelId}`).remove();
  if (this.callTimeouts[chatPanelId]) {
    clearTimeout(this.callTimeouts[chatPanelId]);
    delete this.callTimeouts[chatPanelId];
  }
  this.callTimeouts[chatPanelId] = setTimeout(() => {
    if (this.peerConnections[chatPanelId]) {
      this.peerConnections[chatPanelId].close();
      delete this.peerConnections[chatPanelId];
    }
    delete this.activeCalls[this.peerData[chatPanelId]?.recipient];
  }, 100);
  this.callStates[chatPanelId] = 'ending';
    try {
      console.log(`Ending call for ${chatPanelId}`);
      if (this.callSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
        this.callSockets[chatPanelId].send(JSON.stringify({
          type: "end_call"
        }));
      }
      if (this.localStreams[chatPanelId]) {
        this.localStreams[chatPanelId].getTracks().forEach(track => track.stop());
        delete this.localStreams[chatPanelId];
      }

      if (this.remoteStreams[chatPanelId]) {
        this.remoteStreams[chatPanelId].getTracks().forEach(track => track.stop());
        delete this.remoteStreams[chatPanelId];
      }

      const localVideo = document.getElementById(`localVideoCall-${chatPanelId}`);
      const remoteVideo = document.getElementById(`remoteVideoCall-${chatPanelId}`);

      if (localVideo) {
        localVideo.srcObject = null;
        localVideo.classList.remove("active");
      }

      if (remoteVideo) {
        remoteVideo.srcObject = null;
        remoteVideo.classList.remove("active");
      }

      if (this.peerConnections[chatPanelId]) {
        this.peerConnections[chatPanelId].close();
        delete this.peerConnections[chatPanelId];
      }

      $(`#video-call-container-${chatPanelId}`).hide();
      this.updateCallStatus(chatPanelId, "disconnected");
      delete this.activeCalls[this.peerData[chatPanelId]?.recipient];
      console.log(`Call ended for ${chatPanelId}`);
      const { sender, recipient } = this.peerData[chatPanelId] || {};
      if (sender && recipient) {
        setTimeout(() => {
          if (!this.peerConnections[chatPanelId]) {
            this.initVideoCall(chatPanelId, sender, recipient);
          }
        }, 1000);
      }
    } catch (error) {
      console.error(`Error ending call: ${error}`);
    }
    finally {
      this.callStates[chatPanelId] = 'idle';
    }
}

cleanupVideoCall(chatPanelId) {
  if (this.callSockets[chatPanelId]) {
    this.callSockets[chatPanelId].close();
    delete this.callSockets[chatPanelId];
  }

  if (this.peerConnections[chatPanelId]) {
    this.peerConnections[chatPanelId].close();
    delete this.peerConnections[chatPanelId];
  }

  if (this.localStreams[chatPanelId]) {
    this.localStreams[chatPanelId].getTracks().forEach(track => track.stop());
    delete this.localStreams[chatPanelId];
  }

  if (this.remoteStreams[chatPanelId]) {
    this.remoteStreams[chatPanelId].getTracks().forEach(track => track.stop());
    delete this.remoteStreams[chatPanelId];
  }

  const container = document.getElementById(`video-call-container-${chatPanelId}`);
  if (container) {
    container.style.display = "none";
  }
}

updateCallStatus(chatPanelId, state) {
  const element = document.getElementById(`call-status-${chatPanelId}`);
  element.className = "connection-status";
  const stateMap = {
    connected: "connected",
    completed: "connected",
    checking: "connecting",
    connecting: "connecting",
    disconnected: "disconnected",
    failed: "disconnected",
    closed: "disconnected",
  };

  const statusClass = stateMap[state] || "disconnected";
  element.classList.add(statusClass);
  element.title = `Status: ${state}`;
}

isValidCallMessageType(type) {
  const validTypes = [
    "offer",
    "answer",
    "candidate",
    "call_initiate",
    "call_rejected",
    "end_call",
    "mute_status",
    "video_status"
  ];
  return validTypes.includes(type);
}
isPeerConnectionReady(chatPanelId) {
  return (
    this.peerConnections[chatPanelId] &&
    this.peerConnections[chatPanelId].signalingState !== "closed"
  );
}
showError(chatPanelId, message) {
  console.error(`Error for ${chatPanelId}: ${message}`);
  alert(`Video Call Error: ${message}`);
}
}
function getCookie(name) {
let cookieValue = null;
if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
        }
    }
}
return cookieValue;
}
async function logMissedCall(caller, recipient) {
  try {
      const response = await fetch('/log_missed_call/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken'),
          },
          body: JSON.stringify({
              caller: caller,
              recipient: recipient,
              call_type: 'video',
              reason: 'missed'
          })
      });
      if (!response.ok) throw new Error('Failed to log missed call');
  } catch (error) {
      console.error('Error logging missed call:', error);
  }
}
async function logRejectedCall(caller, recipient) {
  try {
      const response = await fetch('/log_rejected_call/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken'),
          },
          body: JSON.stringify({
              caller: caller,
              receiver: recipient,
              call_type: 'video',
              reason: 'rejected'
          })
      });
      if (!response.ok)
      {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || 'Failed to log rejected call');
      }
      return await response.json();
  } catch (error) {
      console.error('Error logging rejected call:', error);
      throw error;
  }
}
async function logCompletedCall(caller, receiver, duration) {
  try {
    const response = await fetch('/log_completed_call/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken'),
      },
      body: JSON.stringify({
        caller: caller,
        receiver: receiver,
        call_type: 'video',
        duration: duration || 0  // Ensure duration is never undefined
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.message || 'Failed to log completed call');
    }
    return await response.json();
  } catch (error) {
    console.error('Error logging completed call:', {
      error: error.message,
      caller,
      receiver,
      duration
    });
    throw error;
  }
}
const callNotificationSocket = new WebSocket(
  window.location.protocol === "https:"
      ? `wss://${window.location.host}/ws/call_notifications/`
      : `ws://${window.location.host}/ws/call_notifications/`
);
callNotificationSocket.onmessage = function(event) {
try {
  const data = JSON.parse(event.data);
  if (data.type === 'missed_call') {
      window.showMissedCallNotification(data);
      tabNotifier.showNotification(`Missed ${data.call_type} call from ${data.caller}`);
  }
} catch (e) {
  console.error("Error processing call notification:", e);
}
};

function showMissedCallNotification(data) {
  if (document.hidden || data.call_type === 'video') {
    const existingNotification = document.querySelector('.missed-call-notification');
    if (existingNotification) existingNotification.remove();
    const notification = document.createElement('div');
    notification.className = 'missed-call-notification';
    notification.innerHTML = `
        <div class="missed-call-content">
            <div class="missed-call-icon">
                <i class="fas fa-phone-slash"></i>
            </div>
            <div class="missed-call-details">
                <div class="missed-call-title">Missed ${data.call_type} call</div>
                <div class="missed-call-caller">From: ${data.caller}</div>
                <div class="missed-call-time">${new Date(data.timestamp).toLocaleTimeString()}</div>
            </div>
        </div>
    `;
    notification.onclick = function() {
        const chatPanelId = `chat-panel-${data.caller}-${data.caller_id}`;
        const panel = document.getElementById(chatPanelId);
        if (panel) {
            panel.style.display = 'block';
            panel.style.zIndex = '9999';
        }
        notification.remove();
    };
    document.body.appendChild(notification);
    try {
        const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3');
        audio.volume = 0.5;
        audio.play().catch(e => console.log("Audio play failed:", e));
    } catch (e) {
        console.log("Audio error:", e);
    }
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 8000);
    }, 10000);
  }
}
const videoCall = new VideoCall();
class ScreenSharing {
constructor() {
  this.peerConnections = {};
  this.localStreams = {};
  this.makingOffer = {};
  this.ignoreOffer = {};
  this.polite = {};
  this.peerData = {};
  this.shareSockets = {};
  this.messageQueue = {};
  this.rtcConfig = {
    iceServers: [
      {
        urls: "turn:relay1.expressturn.com:3478",
        username: "ef0OSL1KJJM05XK829",
        credential: "4HQgeo0mAcWomtgj",
      },
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:stun1.l.google.com:19302",
          "stun:stun2.l.google.com:19302",
        ],
      },
    ],
    iceTransportPolicy: "all",
    bundlePolicy: "max-bundle",
    rtcpMuxPolicy: "require",
    iceCandidatePoolSize: 10,
  };
}

async initScreenSharing(chatPanelId, sender, recipient) {
  try {
    console.log(`Initializing screen sharing for ${chatPanelId}`);
    this.cleanupScreenSharing(chatPanelId);
    this.peerData[chatPanelId] = {
      sender: sender,
      recipient: recipient,
    };
    this.polite[chatPanelId] = true;
    this.makingOffer[chatPanelId] = false;
    this.ignoreOffer[chatPanelId] = false;

    this.shareSockets[chatPanelId] = new WebSocket(
      window.location.protocol === "https:"
        ? `wss://${window.location.host}/ws/screenshare/${sender}/${recipient}/`
        : `ws://${window.location.host}/ws/screenshare/${sender}/${recipient}/`
    );
    this.shareSockets[chatPanelId].open = async () => {
      if (!this.peerConnections[chatPanelId]) {
        await this.createPeerConnection(chatPanelId);
      }
    };
    this.shareSockets[chatPanelId].sender = sender;
    this.shareSockets[chatPanelId].recipient = recipient;
    this.setupSocketHandlers(chatPanelId);
    this.createVideoElements(chatPanelId);
    this.setupEventListeners(chatPanelId, sender, recipient);

    console.log(`Screen sharing initialized for ${chatPanelId}`);
  } catch (error) {
    console.error(`Error initializing screen sharing: ${error}`);
    this.showError(chatPanelId, "Failed to initialize screen sharing");
  }
}

setupSocketHandlers(chatPanelId) {
  const socket = this.shareSockets[chatPanelId];

  socket.onopen = async () => {
    console.log(`Screen share WebSocket opened for ${chatPanelId}`);
    this.updateConnectionStatus(chatPanelId, "connecting");
    await this.createPeerConnection(chatPanelId);
    this.processMessageQueue(chatPanelId);
  };

  socket.onerror = (error) => {
    console.error(`WebSocket error for ${chatPanelId}:`, error);
    this.updateConnectionStatus(chatPanelId, "disconnected");
    this.cleanupSocket(chatPanelId);
  };

  socket.onclose = () => {
    console.log(`WebSocket closed for ${chatPanelId}`);
    this.updateConnectionStatus(chatPanelId, "disconnected");
  };

  socket.onmessage = async (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log(`Received ${data.type} for ${chatPanelId}`, data);

      if (!this.isValidMessageType(data.type)) {
        console.warn(`Invalid message type: ${data.type}`);
        return;
      }

      if (!this.isPeerConnectionReady(chatPanelId)) {
        console.log(`PeerConnection not ready, queuing ${data.type}`);
        this.queueMessage(chatPanelId, data);
        return;
      }

      await this.processSignalingMessage(chatPanelId, data);
    } catch (error) {
      console.error(
        `Error handling message for ${chatPanelId}:`,
        error
      );
    }
  };
}
cleanupSocket(chatPanelId) {
  if (this.callSockets[chatPanelId]) {
      this.callSockets[chatPanelId].onclose = null;
      this.callSockets[chatPanelId].close();
      delete this.callSockets[chatPanelId];
  }
}
createVideoElements(chatPanelId) {
  const container = document.getElementById(
    `screen-share-container-${chatPanelId}`
  );
  let remoteVideo = document.getElementById(
    `remoteVideo-${chatPanelId}`
  );
  if (remoteVideo) {
    remoteVideo.muted = true;
    remoteVideo.playsInline = true;

    const playPromise = remoteVideo.play();
    if (playPromise !== undefined) {
      playPromise.catch(() => {
        this.showPlayButton(chatPanelId, remoteVideo);
      });
    }
  }
  if (!container) {
    console.error(`Container not found for ${chatPanelId}`);
    return;
  }
  if (!remoteVideo) {
    remoteVideo = document.createElement("video");
    remoteVideo.id = `remoteVideo-${chatPanelId}`;
    remoteVideo.autoplay = true;
    remoteVideo.muted = true;
    remoteVideo.playsInline = true;
    container.appendChild(remoteVideo);
  }
  remoteVideo.onplay = () => {
    const playBtn = container.querySelector(".video-play-button");
    if (playBtn) playBtn.remove();
  };

  if (!document.getElementById(`localVideo-${chatPanelId}`)) {
    const localVideo = document.createElement("video");
    localVideo.id = `localVideo-${chatPanelId}`;
    localVideo.className = "localVideo";
    localVideo.autoplay = true;
    localVideo.muted = true;
    localVideo.playsInline = true;
    container.appendChild(localVideo);
  }

  if (!document.getElementById(`remoteVideo-${chatPanelId}`)) {
    const remoteVideo = document.createElement("video");
    remoteVideo.id = `remoteVideo-${chatPanelId}`;
    remoteVideo.className = "remoteVideo";
    remoteVideo.autoplay = true;
    remoteVideo.muted = true;
    remoteVideo.playsInline = true;
    container.appendChild(remoteVideo);
  }

  if (!document.getElementById(`connection-status-${chatPanelId}`)) {
    const statusIndicator = document.createElement("div");
    statusIndicator.id = `connection-status-${chatPanelId}`;
    statusIndicator.className = "connection-status";
    container.appendChild(statusIndicator);
  }
}
showPlayButton(chatPanelId) {
  const container = document.getElementById(
    `screen-share-container-${chatPanelId}`
  );
  const video = document.getElementById(`remoteVideo-${chatPanelId}`);
  if (!container || !video) return;
  const existingBtn = container.querySelector(".video-play-button");
  if (existingBtn) existingBtn.remove();

  const playBtn = document.createElement("button");
  playBtn.className = "video-play-button";
  playBtn.textContent = "Play Video";
  playBtn.onclick = () => {
    video.play().catch((e) => console.error("Playback failed:", e));
  };
  container.appendChild(playBtn);
}
setupEventListeners(chatPanelId, sender, recipient) {
  $(`#shareBtn-${chatPanelId}`)
    .off("click")
    .on("click", async () => {
      if (this.localStreams[chatPanelId]) {
        await this.stopScreenShare(chatPanelId);
      } else {
        await this.startScreenShare(chatPanelId, sender, recipient);
      }
    });

  $(document).on(
    `click`,
    `.close-chat-content[data-id="${chatPanelId}"]`,
    () => {
      this.cleanupScreenSharing(chatPanelId);
    }
  );
}

async startScreenShare(chatPanelId, sender, recipient) {
  try {
    console.log(`Starting screen share for ${chatPanelId}`);
    $(`#screen-share-container-${chatPanelId}`).show();
    this.updateConnectionStatus(chatPanelId, "connecting");
    if (!(await this.createPeerConnection(chatPanelId))) {
      throw new Error("Failed to create peer connection");
    }
    await this.createPeerConnection(chatPanelId);
    this.localStreams[chatPanelId] =
      await navigator.mediaDevices.getDisplayMedia({
        video: {
          displaySurface: "monitor",
        },
        audio: false,
      });
    const localVideo = document.getElementById(
      `localVideo-${chatPanelId}`
    );
    if (localVideo) {
      localVideo.srcObject = this.localStreams[chatPanelId];
      localVideo.classList.add("active");
      localVideo
        .play()
        .catch((e) => console.log("Local video play error:", e));
    }
    this.localStreams[chatPanelId].getTracks().forEach((track) => {
      this.peerConnections[chatPanelId].addTrack(
        track,
        this.localStreams[chatPanelId]
      );
      console.log(`Added ${track.kind} track to peer connection`);
      track.onended = () => {
        console.log("Screen sharing track ended");
        this.stopScreenShare(chatPanelId);
      };
    });
    this.localStreams[chatPanelId].getVideoTracks()[0].onended = () => {
      console.log("User stopped screen sharing");
      this.stopScreenShare(chatPanelId);
    };

    console.log(`Screen sharing started for ${chatPanelId}`);
  } catch (error) {
    console.error(`Error starting screen share: ${error}`);
    this.stopScreenShare(chatPanelId);
    if (error.name !== "NotAllowedError") {
      this.showError(
        chatPanelId,
        `Could not start screen sharing: ${error.message}`
      );
    }
  }
}

async createPeerConnection(chatPanelId) {
  if (this.peerConnections[chatPanelId]) {
    this.peerConnections[chatPanelId].close();
    delete this.peerConnections[chatPanelId];
  }

  try {
    console.log(`Creating PeerConnection for ${chatPanelId}`);
    if (this.peerConnections[chatPanelId]) {
      this.peerConnections[chatPanelId].close();
    }
    this.peerConnections[chatPanelId] = new RTCPeerConnection(
      this.rtcConfig
    );
    this.updateConnectionStatus(chatPanelId, "connecting");
    this.setupPeerConnectionHandlers(chatPanelId);
    console.log(`PeerConnection created for ${chatPanelId}`);
    return true;
  } catch (error) {
    console.error(`Error creating PeerConnection: ${error}`);
    this.updateConnectionStatus(chatPanelId, "disconnected");
    return false;
  }
}

setupPeerConnectionHandlers(chatPanelId) {
  const pc = this.peerConnections[chatPanelId];
  if (!pc) return;
  const [_, sender, recipient] =
    chatPanelId.match(/chat-panel-(.+?)-(\d+)/) || [];
  pc.onicecandidate = ({ candidate }) => {
    console.log(`ICE candidate for ${chatPanelId}:`, candidate);
    if (
      candidate &&
      this.shareSockets[chatPanelId]?.readyState === WebSocket.OPEN
    ) {
      this.shareSockets[chatPanelId].send(
        JSON.stringify({
          type: "candidate",
          candidate: candidate,
        })
      );
    }
  };

  pc.onnegotiationneeded = async () => {
    try {
      console.log(`Negotiation needed for ${chatPanelId}`);
      this.makingOffer[chatPanelId] = true;
      await pc.setLocalDescription();
      console.log(`Local description set:`, pc.localDescription);

      if (
        this.shareSockets[chatPanelId]?.readyState === WebSocket.OPEN
      ) {
        this.shareSockets[chatPanelId].send(
          JSON.stringify({
            type: "offer",
            offer: pc.localDescription,
          })
        );
        console.log(`Offer sent for ${chatPanelId}`);
      }
    } catch (err) {
      console.error(`Negotiation error for ${chatPanelId}:`, err);
    } finally {
      this.makingOffer[chatPanelId] = false;
    }
  };

  pc.oniceconnectionstatechange = () => {
    const state = pc.iceConnectionState;
    console.log(
      `ICE connection state changed to ${state} for ${chatPanelId}`
    );
    this.updateConnectionStatus(chatPanelId, state);
    if (pc.iceConnectionState === "failed") {
      pc.restartIce();
    }
    if (state === "failed") {
      console.log(`Restarting ICE for ${chatPanelId}`);
      pc.restartIce();
    }
  };
  pc.ontrack = (event) => {
    console.log("Track event received:", event);
    const remoteVideo = document.getElementById(
      `remoteVideo-${chatPanelId}`
    );
    if (!remoteVideo) {
      console.error("Remote video element not found");
      return;
    }
    if (remoteVideo.srcObject) {
      remoteVideo.srcObject
        .getTracks()
        .forEach((track) => track.stop());
    }
    remoteVideo.playsInline = true;
    remoteVideo.muted = true;

    if (remoteVideo.srcObject) {
      remoteVideo.srcObject
        .getTracks()
        .forEach((track) => track.stop());
    }
    if (event.streams && event.streams.length > 0) {
      console.log(
        "Attaching remote stream with tracks:",
        event.streams[0].getTracks().map((t) => t.kind)
      );

      remoteVideo.srcObject = event.streams[0];
      remoteVideo.playsInline = true;
      remoteVideo.muted = true;
      const playPromise = remoteVideo.play();
      if (playPromise !== undefined) {
        playPromise.catch((error) => {
          console.log("Autoplay prevented, showing play button");
          this.showPlayButton(chatPanelId, remoteVideo);
        });
      }
      $(`#screen-share-container-${chatPanelId}`).show();
      this.ensureVideoPlayback(remoteVideo, chatPanelId);
    }
  };
  pc.onicegatheringstatechange = () => {
    console.log(
      `ICE gathering state for ${chatPanelId}: ${pc.iceGatheringState}`
    );
  };

  pc.onsignalingstatechange = () => {
    console.log(
      `Signaling state for ${chatPanelId}: ${pc.signalingState}`
    );
  };

  pc.onconnectionstatechange = () => {
    const state = pc.connectionState;
    console.log(
      `Connection state changed to ${state} for ${chatPanelId}`
    );

    switch (state) {
      case "connected":
        this.handleConnectionSuccess(chatPanelId);
        break;
      case "failed":
        setTimeout(() => {
          if (pc.iceConnectionState !== "closed") {
            pc.restartIce();
            console.log("ICE RESTARTING");
          }
        }, 10000);
        break;
      case "disconnected":
        this.cleanupScreenSharing(chatPanelId);
        break;
    }
  };
}
handleConnectionSuccess(chatPanelId) {
console.log(`Connection established for ${chatPanelId}`);
const statusElement = document.getElementById(`connection-status-${chatPanelId}`);
if (statusElement) {
    statusElement.className = "connection-status connected";
  }
this.monitorConnectionQuality(chatPanelId);
}

monitorConnectionQuality(chatPanelId) {
  const pc = this.peerConnections[chatPanelId];
  if (!pc) return;
    setInterval(() => {
      pc.getStats().then(stats => {
        stats.forEach(report => {
            if (report.type === 'candidate-pair' && report.nominated) {
                console.log(`Connection quality for ${chatPanelId}:`, {
                    rtt: report.currentRoundTripTime,
                    availableOutgoingBitrate: report.availableOutgoingBitrate
                });
            }
        });
    });
  }, 60000);
}
handleConnectionFailure(chatPanelId) {
  this.cleanupScreenSharing(chatPanelId);

  const { sender, recipient } = this.peerData[chatPanelId] || {};
  if (!sender || !recipient) return;
  if (sender && recipient) {
    setTimeout(() => {
      this.initScreenSharing(chatPanelId, sender, recipient);
    }, 5000);
  }
}
ensureVideoPlayback(videoElement, chatPanelId, attempt = 0) {
  if (attempt > 3) {
    console.error("Max playback attempts reached");
    this.showPlayButton(chatPanelId, videoElement);
    return;
  }

  videoElement
    .play()
    .then(() => {
      console.log("Video playback started successfully");
      videoElement.classList.add("active");
    })
    .catch((error) => {
      console.warn(`Playback attempt ${attempt + 1} failed:`, error);
      if (error.name === "NotAllowedError") {
        this.showPlayButton(chatPanelId, videoElement);
      } else {
        setTimeout(() => {
          this.ensureVideoPlayback(
            videoElement,
            chatPanelId,
            attempt + 1
          );
        }, 10000);
      }
    });
}
handleVideoPlayback(videoElement, chatPanelId) {
  videoElement.muted = true;
  const playPromise = videoElement.play();
  if (playPromise !== undefined) {
    playPromise
      .catch((error) => {
        console.log("Autoplay prevented, showing play button");
        this.showPlayButton(chatPanelId, videoElement);
      })
      .then(() => {
        console.log("Video playback started successfully");
      });
  }
}

showPlayButton(chatPanelId, videoElement) {
  const container = document.getElementById(
    `screen-share-container-${chatPanelId}`
  );
  if (!container) return;
  const existingBtn = container.querySelector(".video-play-button");
  if (existingBtn) existingBtn.remove();
  const playBtn = document.createElement("button");
  playBtn.className = "video-play-button btn btn-primary";
  playBtn.textContent = "Play Video";
  playBtn.onclick = () => {
    videoElement
      .play()
      .then(() => {
        playBtn.remove();
        console.log("Playback started after user interaction");
      })
      .catch((e) => {
        console.error("Playback failed:", e);
        this.showError(chatPanelId, "Could not start video playback");
      });
  };

  container.appendChild(playBtn);
}

async processSignalingMessage(chatPanelId, data) {
  if (!this.peerConnections[chatPanelId]) {
    console.log(`PeerConnection not ready, queuing ${data.type}`);
    this.queueMessage(chatPanelId, data);
    return;
  }

  const pc = this.peerConnections[chatPanelId];
  const currentDescription =
    pc.remoteDescription || pc.localDescription;

  if (currentDescription && data.type === currentDescription.type) {
    console.log(`Ignoring duplicate ${data.type}`);
    return;
  }
  switch (data.type) {
    case "offer":
      await this.handleOffer(chatPanelId, data.offer);
      break;
    case "answer":
      await this.handleAnswer(chatPanelId, data.answer);
      break;
    case "candidate":
      await this.handleCandidate(chatPanelId, data.candidate);
      break;
    case "stop_screen_share":
      await this.stopScreenShare(chatPanelId);
      break;
  }
}
async handleOffer(chatPanelId, offer) {
  try {
    const pc = this.peerConnections[chatPanelId];
    if (!pc) return;

    const offerCollision =
      this.makingOffer[chatPanelId] ||
      (pc.signalingState !== "stable" &&
        pc.signalingState !== "have-local-offer");

    this.ignoreOffer[chatPanelId] =
      !this.polite[chatPanelId] && offerCollision;
    if (this.ignoreOffer[chatPanelId]) {
      console.log(`Ignoring offer for ${chatPanelId} due to collision`);
      return;
    }
    this.messageQueue[chatPanelId] = [];

    await pc.setRemoteDescription(new RTCSessionDescription(offer));

    if (offer.type === "offer") {
      await pc.setLocalDescription();
      this.shareSockets[chatPanelId].send(
        JSON.stringify({
          type: "answer",
          answer: pc.localDescription,
        })
      );
    }
  } catch (error) {
    console.error(`Error handling offer: ${error}`);
    this.cleanupScreenSharing(chatPanelId);
  }
}
async handleAnswer(chatPanelId, answer) {
  try {
    console.log("Processing answer", answer);
    const pc = this.peerConnections[chatPanelId];

    if (!pc || pc.signalingState === "closed") {
      console.warn("PeerConnection not ready for answer");
      return;
    }

    if (
      pc.signalingState === "have-local-offer" ||
      pc.signalingState === "stable"
    ) {
      if (!pc.remoteDescription) {
        await pc.setRemoteDescription(
          new RTCSessionDescription(answer)
        );
        console.log("Answer processed successfully");
      } else {
        console.log("Ignoring duplicate answer");
      }
    } else {
      console.warn(
        `Unexpected signaling state for answer: ${pc.signalingState}`
      );
      this.queueMessage(chatPanelId, { type: "answer", answer });
    }
  } catch (error) {
    console.error("Error handling answer:", error);
    throw error;
  }
}
async handleCandidate(chatPanelId, candidate) {
  try {
    const pc = this.peerConnections[chatPanelId];
    if (!pc || pc.signalingState === "closed") return;
    if (!candidate || this.ignoreOffer[chatPanelId]) return;
    if (
      candidate.candidate.includes("typ host") &&
      pc.remoteDescription &&
      pc.remoteDescription.type === "answer"
    ) {
      console.log("Skipping host candidate after answer");
      return;
    }
    await pc.addIceCandidate(new RTCIceCandidate(candidate));
  } catch (err) {
    if (!this.ignoreOffer[chatPanelId]) {
      console.error("Failed to add ICE candidate:", err);
    }
  }
}
async stopScreenShare(chatPanelId) {
  try {
    console.log(`Stopping screen share for ${chatPanelId}`);
    if (this.localStreams[chatPanelId]) {
      this.localStreams[chatPanelId]
        .getTracks()
        .forEach((track) => track.stop());
      delete this.localStreams[chatPanelId];
    }
    const localVideo = document.getElementById(
      `localVideo-${chatPanelId}`
    );
    const remoteVideo = document.getElementById(
      `remoteVideo-${chatPanelId}`
    );
    if (localVideo) {
      localVideo.srcObject = null;
      localVideo.classList.remove("active");
    }
    if (remoteVideo) {
      remoteVideo.srcObject = null;
      remoteVideo.classList.remove("active");
    }
    if (this.peerConnections[chatPanelId]) {
      this.peerConnections[chatPanelId].close();
      delete this.peerConnections[chatPanelId];
    }
    this.updateConnectionStatus(chatPanelId, "disconnected");
    if (this.shareSockets[chatPanelId]?.readyState === WebSocket.OPEN) {
      this.shareSockets[chatPanelId].send(
        JSON.stringify({
          type: "stop_screen_share",
        })
      );
    }

    console.log(`Screen sharing stopped for ${chatPanelId}`);
    const { sender, recipient } = this.peerData[chatPanelId] || {};
    if (sender && recipient) {
        setTimeout(() => {
            this.initScreenSharing(chatPanelId, sender, recipient);
        }, 10000);
    }
  } catch (error) {
    console.error(`Error stopping screen share: ${error}`);
  }
}

cleanupScreenSharing(chatPanelId) {
  if (this.shareSockets[chatPanelId]) {
    this.shareSockets[chatPanelId].close();
    delete this.shareSockets[chatPanelId];
  }
  if (this.peerConnections[chatPanelId]) {
    this.peerConnections[chatPanelId].close();
    delete this.peerConnections[chatPanelId];
  }
  if (this.localStreams[chatPanelId]) {
    this.localStreams[chatPanelId]
      .getTracks()
      .forEach((track) => track.stop());
    delete this.localStreams[chatPanelId];
  }
  const container = document.getElementById(
    `screen-share-container-${chatPanelId}`
  );
  if (container) {
    container.style.display = "none";
  }
}

cleanupSocket(chatPanelId) {
  if (this.shareSockets[chatPanelId]) {
    this.shareSockets[chatPanelId].close();
    delete this.shareSockets[chatPanelId];
  }
}

async processMessageQueue(chatPanelId) {
  if (
    !this.messageQueue[chatPanelId] ||
    this.messageQueue[chatPanelId].length === 0
  ) {
    return;
  }

  console.log(
    `Processing ${this.messageQueue[chatPanelId].length} queued messages for ${chatPanelId}`
  );

  while (
    this.messageQueue[chatPanelId].length > 0 &&
    this.isPeerConnectionReady(chatPanelId)
  ) {
    const message = this.messageQueue[chatPanelId].shift();
    try {
      await this.processSignalingMessage(chatPanelId, message);
    } catch (error) {
      console.error(`Error processing queued ${message.type}:`, error);
    }
  }
}

queueMessage(chatPanelId, message) {
  if (!this.messageQueue[chatPanelId]) {
    this.messageQueue[chatPanelId] = [];
  }
  this.messageQueue[chatPanelId].push(message);
  console.log(`Message queued for ${chatPanelId}:`, message.type);
}

updateConnectionStatus(chatPanelId, state) {
  const element = document.getElementById(
    `connection-status-${chatPanelId}`
  );

  element.className = "connection-status";
  const stateMap = {
    connected: "connected",
    completed: "connected",
    checking: "connecting",
    connecting: "connecting",
    disconnected: "disconnected",
    failed: "disconnected",
    closed: "disconnected",
  };

  const statusClass = stateMap[state] || "disconnected";
  element.classList.add(statusClass);
  element.title = `Status: ${state}`;
}

showError(chatPanelId, message) {
  console.error(`Error for ${chatPanelId}: ${message}`);
  alert(`Screen Sharing Error: ${message}`);
}

isValidMessageType(type) {
  const validTypes = [
    "offer",
    "answer",
    "candidate",
    "stop_screen_share",
  ];
  return validTypes.includes(type);
}

isPeerConnectionReady(chatPanelId) {
  return (
    this.peerConnections[chatPanelId] &&
    this.peerConnections[chatPanelId].signalingState !== "closed"
  );
}
}

const screenSharing = new ScreenSharing();

var onlineSocket = new WebSocket(
"ws://" + window.location.host + "/ws/online/"
);
onlineSocket.onmessage = function (event) {
var data = JSON.parse(event.data);
if (data.type === "update_online_users") {
  updateOnlineUserList(data.online_users);
}
};
function updateOnlineUserList(onlineUsers) {
document.querySelectorAll(".user-status").forEach((element) => {
  element.classList.remove("online");
  element.classList.add("offline");
});
onlineUsers.forEach((user) => {
  let userElement = document.getElementById(
    "user-status-" + user.user__id
  );
  if (userElement) {
    userElement.classList.remove("offline");
    userElement.classList.add("online");
  }
});
}
document.querySelector(".menu-toggle").addEventListener("click", () => {
document.querySelector(".nav-menu").classList.toggle("active");
});
$(document).ready(function () {
let chatPanels = [];

$(".chat-button").click(function () {
  $(".chat-panel").toggleClass("active");
  updateChatPanelPositions();
});
$(".close-chat").click(function () {
  $(".chat-panel").removeClass("active");
  updateChatPanelPositions();
});
let panelOffset = 0;
function updateChatPanelPositions() {
    const chatListPanelOpen = $('.chat-panel').hasClass('active');
    const visiblePanels = chatPanels.filter(id => !$(`#${id}`).hasClass('minimized'));
    if (visiblePanels.length <= 3) {
        panelOffset = 0;
    }
    const startRight = chatListPanelOpen ? 310 : 20;
    const panelWidth = 300;
    const gap = 8;
    const maxVisible = 3;
    const totalVisible = Math.min(maxVisible, visiblePanels.length);
    const panelsToShow = [];
    for (let i = 0; i < totalVisible; i++) {
        const index = (panelOffset + i) % visiblePanels.length;
        panelsToShow.push(visiblePanels[index]);
    }
    const rightMostPosition = startRight + ((totalVisible - 1) * (panelWidth + gap));
    panelsToShow.forEach((panelId, index) => {
        const position = rightMostPosition - (index * (panelWidth + gap));
        $(`#${panelId}`).css({
            right: position + 'px',
            display: 'block',
            zIndex: 1030 + (totalVisible - index)
        });
    });
}
window.addEventListener('wheel', function(e) {
    const visiblePanels = chatPanels.filter(id => !$(`#${id}`).hasClass('minimized'));
    const maxVisible = 3;
    const totalPanels = visiblePanels.length;
    if (totalPanels <= maxVisible) return;
    e.preventDefault();
    if (e.deltaY > 0) {
        panelOffset = (panelOffset + 1) % totalPanels;
    } else {
        panelOffset = (panelOffset - 1 + totalPanels) % totalPanels;
    }
    updateChatPanelPositions();
}, { passive: false });
$(".chat-list li").click(function () {
  let username = $(this).data("username");
  let userId = $(this).data("id");
  let chatPanelId = "chat-panel-" + username + "-" + userId;
  let sender = "{{ request.user.username }}";
  let recipient = username;
  let chatMessages = "${chat-messages}";
  let existingIndex = chatPanels.indexOf(chatPanelId);
  let typingTimeout;
  let lastTypingTime = 0;
  let isTyping = false;
  const TYPING_TIMEOUT = 5000;
  if (existingIndex >= 0) {
    chatPanels.splice(existingIndex, 1);
    chatPanels.unshift(chatPanelId);
    $(`#${chatPanelId}`).addClass("active");
    bringPanelToFront(chatPanelId);
    markMessagesAsRead(username);
    updateChatPanelPositions();
    return;
  }
  console.log("Chat Panel", chatPanelId);
  loadOldMessages(sender, recipient, chatMessages, chatPanelId);

  let chatPanel = $(`
    <div class="chat-content-panel" id="${chatPanelId}">
        <div class="chat-header" style="font-family: serif;">
          <div class="header-user-info">
            <span class="header-username">${username}</span>
            <div class="typing-indicator" id="typing-indicator-${chatPanelId}" style="display: none;">
              <div class="typing-dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
              </div>
              <span class="typing-text">typing...</span>
            </div>
          </div>
            <div>
                <button class="minimize-chat" data-id="${chatPanelId}">−</button>
                <button class="maximize-chat" data-id="${chatPanelId}">□</button>
                <button class="close-chat-content" data-id="${chatPanelId}">&times;</button>
            </div>
        </div>
        <div class="chat-container">
            <div class="container">
                <div class="chat-container2">
                  <div class="messages" id="chat-messages-${chatPanelId}" class="chat-messages"></div>
                    <div class="media-containers">

                      <div class="video-call-container" id="video-call-container-${chatPanelId}" style="display: none;">
                          <video id="localVideoCall-${chatPanelId}" class="localVideo" autoplay muted></video>
                          <video id="remoteVideoCall-${chatPanelId}" class="remoteVideo" autoplay></video>
                          <div class="call-controls">
                              <button class="end-call-btn" id="end-call-btn-${chatPanelId}"><img alt="end call" src="https://img.icons8.com/?size=100&id=20578&format=png&color=000000"></button>
                              <button class="mute-btn" id="mute-btn-${chatPanelId}"><img alt="Mute" src="https://img.icons8.com/?size=100&id=JtlARuXJXaPI&format=png&color=000000"></button>
                              <button class="video-off-btn" id="video-off-btn-${chatPanelId}"><img src="https://img.icons8.com/?size=100&id=GQ1GoxtCGHG4&format=png&color=000000" alt="Video off"></button>
                          </div>
                      </div>
                      <div class="screen-share-container" id="screen-share-container-${chatPanelId}" style="display: none;">
                          <video id="localVideo-${chatPanelId}" class="localVideo" autoplay muted></video>
                          <video id="remoteVideo-${chatPanelId}" class="remoteVideo" autoplay></video>
                      </div>
                    </div>
                  </div>
                  <div class="chat-input" id="chat-input">
                    <input autocomplete="off" type="text" class="message-input" id="message-input-${chatPanelId}" placeholder="Type your message...">
                    <button id="send-btn-${chatPanelId}" class="send-btn">
                      <img src="https://img.icons8.com/?size=100&id=2837&format=png&color=000000" alt="send">
                    </button>
                    <button id="shareBtn-${chatPanelId}" class="shareBtn">
                      <img src="https://img.icons8.com/?size=100&id=sIozg7PYECHb&format=png&color=000000" alt="share">
                    </button>
                    <button id="video-call-btn-${chatPanelId}" class="video-call-btn">
                      <img src="https://img.icons8.com/?size=100&id=OomoDjxpvJzW&format=png&color=000000" alt="Video call">
                    </button>
                </div>
            </div>
        </div>
    </div>
    `);
  $("body").append(chatPanel);
  chatPanels.push(chatPanelId);
  $(`#${chatPanelId}`).addClass("active");
  console.log("Initializing chat WebSocket...");
  console.log(sender, recipient);
  bringPanelToFront(chatPanelId);
  markMessagesAsRead(username);

  let chatSocket = new WebSocket(
    `ws://${window.location.host}/ws/chat/${sender}/${recipient}/`
  );

  $(document).on("click", `#send-btn-${chatPanelId}`, function () {
    markMessagesAsRead(username)
    stopTyping();
    sendMessage(chatSocket, chatPanelId);
  });
  $(`#message-input-${chatPanelId}`).keypress(function (event) {
    markMessagesAsRead(username)
    stopTyping();
    if (event.key === "Enter") sendMessage(chatSocket, chatPanelId);
  });
  $(`#message-input-${chatPanelId}`).on('input', function() {
    const now = Date.now();
    if (now - lastTypingTime < 300) return;
    lastTypingTime = now;
    const message = $(this).val().trim();
    if (message.length > 0) {
        if (!isTyping) {
            isTyping = true;
            chatSocket.send(JSON.stringify({
                type: "typing",
                sender: "{{ request.user.username }}",
                recipient: username
            }));
            console.log("{{ request.user.username }} is Typing");
            console.log("Typing ...")
        }
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(stopTyping, TYPING_TIMEOUT);
    } else {
        stopTyping();
    }
  });
  function stopTyping() {
    if (isTyping) {
        isTyping = false;
        clearTimeout(typingTimeout);
        chatSocket.send(JSON.stringify({
            type: "stopped_typing",
            sender: "{{ request.user.username }}",
            recipient: username
        }));
    }
  }
  function sendMessage(chatSocket, chatPanelId) {
    const messageInput = $(`#message-input-${chatPanelId}`);
    const message = messageInput.val().trim();
    if (!message) return;
    chatSocket.send(JSON.stringify({ message: message }));
    messageInput.val("");
  }

  $(document).on("click", ".close-chat-content", function () {
    let panelId = $(this).data("id");
    $("#" + panelId).remove();
    chatPanels = chatPanels.filter((id) => id !== panelId);
    updateChatPanelPositions();
  });
  function bringPanelToFront(panelId) {
    let panel = $("#" + panelId);
    panel.css(
      "z-index",
      Math.max(...chatPanels.map((id) => $("#" + id).css("z-index"))) +
        1
    );
  }

  chatSocket.onmessage = function (event) {
    const data = JSON.parse(event.data);
    if (data.type === "typing" && data.sender !== "{{ request.user.username }}") {
        const indicator = $(`#typing-indicator-${chatPanelId}`);
        indicator.find('.typing-text').text('typing...');
        indicator.css('display', 'flex'); // Use flex to maintain alignment
        console.log("Showing typing indicator for", data.sender);
        indicator.show();
        console.log("showing indicator...");
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            indicator.hide();
        }, TYPING_TIMEOUT);
    }
    else if (data.type === "stopped_typing" && data.sender !== "{{ request.user.username }}") {
        $(`#typing-indicator-${chatPanelId}`).hide();
        console.log("hiding typing indicator", data.sender);
    }
    else if (data.message) {
        $(`#typing-indicator-${chatPanelId}`).removeClass('show');
        renderMessage(data, chatPanelId);
        if (!document.hasFocus() || $(`#${chatPanelId}`).hasClass('minimized') || !$(`#${chatPanelId}`).is(':visible')) {
            tabNotifier.showNotification(`${data.sender}: ${data.message}`);
        }
    }
  };
  let zIndexCounter = 1100;
  $(document).on('click', '.maximize-chat', function() {
    const panelId = $(this).data('id');
    const panel = $(`#${panelId}`);
    const button = $(this);
    if (panel.hasClass('maximized')) {
      panel.removeClass('maximized').css('z-index', '1030');
      button.text('□');
      $(`#screen-share-container-${panelId}`).css('height', 'auto');
    } else {
      panel.addClass('maximized').css('z-index', ++zIndexCounter);
      button.text('❐');
      $(`#screen-share-container-${panelId}`).css('height', '50%');
    }
    markMessagesAsRead(username);
  });
  $(document).on('click', '.chat-content-panel.maximized', function() {
    $(this).css('z-index', ++zIndexCounter);
  });

 $(document).on('click', '.minimize-chat', function() {
    const panelId = $(this).data('id');
    const panel = $(`#${panelId}`);
    panel.toggleClass('minimized');
    bringPanelToFront(panelId);
});
$(document).on('click', '.chat-content-panel.minimized .chat-header', function() {
    const panel = $(this).closest('.chat-content-panel');
    panel.removeClass('minimized');
    markMessagesAsRead(username);
    bringPanelToFront(panel.attr('id'));
});
  function renderMessage(data, chatPanelId) {
    const chatMessages = $(`#chat-messages-${chatPanelId}`);
    let chatPanel = $("#" + chatPanelId);
    const newMessage = `
<div class="message-container ${
  data.sender === "{{ request.user.username }}" ? "me" : "other"
}">
    <div class="message-bubble">
        <div class="username">${data.sender}</div>
        <div class="message-content">${data.message || ""}</div>
        <div class="message-timestamp">${new Date().toLocaleTimeString()}</div>
    </div>
</div>`;
    chatMessages.append(newMessage);
    chatMessages.scrollTop(chatMessages.prop("scrollHeight"));
  }
  updateChatPanelPositions();
  markMessagesAsRead(username);
});
$(document).on('click', '.chat-content-panel', function() {
  tabNotifier.clearNotifications();
});

$(window).on('focus', function() {
  tabNotifier.clearNotifications();
});
function loadOldMessages(sender, recipient, chatMessages, chatPanelId) {
  $.ajax({
    url: `/load-messages/${sender}/${recipient}/`,
    type: "GET",
    success: function (data) {
      const chatMessages = $(
        `#${chatPanelId} #chat-messages-${chatPanelId}`
      );
      data.messages.forEach((msg) => {
        const newMessage = `
                <div class="message-container ${
                  msg.sender === sender ? "me" : "other"
                }">
                    <div class="message-bubble">
                        <div class="username">${msg.sender}</div>
                        <div class="message-content">${
                          msg.content
                        }</div>
                        <div class="message-timestamp">${
                          msg.timestamp
                        }</div>
                    </div>
                </div>`;
        chatMessages.append(newMessage);
      });
      chatMessages.scrollTop(chatMessages.prop("scrollHeight"));
    },
    error: function (error) {
      console.error("Error loading messages:", error);
    },
  });
}

$(document).on("click", ".close-chat-content", function () {
  let panelId = $(this).data("id");
  $("#" + panelId).remove();
  chatPanels = chatPanels.filter((id) => id !== panelId);
});

var notificationSocket = new WebSocket(
  "ws://" + window.location.host + "/ws/notifications/"
);
notificationSocket.onmessage = function (event) {
  var data = JSON.parse(event.data);
  if (data.type === "unread_count") {
    updateUnreadCounts(data.unread_counts);
  }
};

function markMessagesAsRead(username) {
  $.ajax({
    url: "/mark-as-read/",
    type: "POST",
    data: {
      username: username,
      csrfmiddlewaretoken: "{{ csrf_token }}",
    },
    success: function (response) {
      $("#notification-badge-" + username).hide();
      $("#chat-notification").hide();
    },
  });
}
$(".chat-list li").click(function () {
  const username = $(this).data("username");
  const userId = $(this).data("id");
  const chatPanelId = `chat-panel-${username}-${userId}`;
  const sender = "{{ request.user.username }}";
  const recipient = username;
  if (!document.getElementById(`connection-status-${chatPanelId}`)) {
    $(`#${chatPanelId} .chat-header`).append(
      `<div class="connection-status" id="connection-status-${chatPanelId}"></div>`
    );
  }
  screenSharing.initScreenSharing(chatPanelId, sender, recipient);
  videoCall.initVideoCall(chatPanelId, sender, recipient);
});
function updateUnreadCounts(unreadCounts) {
  let userItems = document.querySelectorAll(".chat-list li");
  userItems.forEach((item) => {
    let username = item.getAttribute("data-username");
    let unreadCount = unreadCounts[username] || 0;
    let badge = document.getElementById(
      "notification-badge-" + username
    );
    if (badge) {
      badge.innerText = unreadCount;
      badge.style.display = unreadCount > 0 ? "inline-block" : "none";
    }
  });
  let totalUnread = Object.values(unreadCounts).reduce(
    (sum, count) => sum + count,
    0
  );
  if (totalUnread > 0) {
    $("#chat-notification").show();
  } else {
    $("#chat-notification").hide();
  }
}
});
function updateFavicon(count) {
return new Promise((resolve) => {
  const canvas = document.createElement('canvas');
  const size = 34;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const drawDefaultIcon = () => {
    ctx.fillStyle = '#6c5ce7';
    ctx.fillRect(0, 0, size, size);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('C', size/2, size/2);
    drawNotificationBadge(count);
  };

  const drawNotificationBadge = (count) => {
    if (count > 0) {
      ctx.fillStyle = '#ff4757';
      ctx.beginPath();
      ctx.arc(size - 8, 8, 8, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = 'bold 15px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(count > 9 ? '9+' : count.toString(), size - 8, 8);
    }
    updateFaviconElement(canvas);
    resolve();
  };
  const updateFaviconElement = (canvas) => {
    const oldLinks = document.querySelectorAll('link[rel~="icon"]');
    oldLinks.forEach(oldLink => document.head.removeChild(oldLink));
    const link = document.createElement('link');
    link.type = 'image/png';
    link.rel = 'icon';
    link.href = canvas.toDataURL('image/png');
    document.head.appendChild(link);
  };
  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.src = '{% static "img/image01.png" %}?' + new Date().getTime();

  img.onload = () => {
    const ratio = Math.min(size / img.width, size / img.height);
    const width = img.width * ratio;
    const height = img.height * ratio;
    ctx.drawImage(img, (size - width) / 2, (size - height) / 2, width, height);
    drawNotificationBadge(count);
  };

  img.onerror = () => {
    console.log('Using fallback favicon');
    drawDefaultIcon();
  };
});
}

class TabNotifier {
constructor() {
  this.originalTitle = document.title;
  this.notificationCount = 0;
  this.blinkInterval = null;
  this.isWindowFocused = true;
  window.addEventListener('focus', () => {
    this.isWindowFocused = true;
    this.clearNotifications();
  });

  window.addEventListener('blur', () => {
    this.isWindowFocused = false;
  });
}

async showNotification(message = null) {
  if (this.isWindowFocused) return;
  this.notificationCount++;
  this.updateTitle();
  await updateFavicon(this.notificationCount);
  if (Notification.permission !== "granted") {
    Notification.requestPermission().then(permission => {
      if (permission === "granted" && message) {
        new Notification('New message', {
          body: message,
          icon: '{% static "img/ProfilePic.png" %}'
        });
      }
    });
  } else if (message) {
    new Notification('New message', {
      body: message,
      icon: '{% static "img/ProfilePic.png" %}'
    });
  }
  if (!this.blinkInterval) {
    this.startBlinking();
  }
}
async clearNotifications() {
  this.notificationCount = 0;
  document.title = this.originalTitle;
  await updateFavicon(0);
  if (this.blinkInterval) {
    clearInterval(this.blinkInterval);
    this.blinkInterval = null;
  }
}
updateTitle() {
  document.title = `(${this.notificationCount}) ${this.originalTitle}`;
}
startBlinking() {
  let showOriginal = true;
  this.blinkInterval = setInterval(() => {
    document.title = showOriginal
      ? `(${this.notificationCount}) New message!`
      : `(${this.notificationCount}) ${this.originalTitle}`;
    showOriginal = !showOriginal;
  }, 1000);
}
}
const tabNotifier = new TabNotifier();
</script>
</body>
</html>